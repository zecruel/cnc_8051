;**************************************************************
;* Programa: serial_ed30.asm									*
;* Autor: Ezequiel Rabelo de Aguiar								*
;* Objetivo: Implementar um controle CNC com  o at89c2051			*
;* Caracteristicas:											*
;* 	- Comunicacao Serial, protocolo Modbus RTU					*
;*	- Controle de 3 motores de passo independentes					*
;*	- Compatibilidade com o EdSim *
;* Funcoes Modbus implementadas:
;* 	- funcao 08 sub funcao 00 - Função simples de diagnostico
;*	- funcao 03 - ler um ou mais registros
;*	- funcao 16 - escrever um ou mais registros
;*	- quantidade de registros (escrita e leitura) - 09
;*	- o endereco do equipamento eh definido em tempo de compliacao
;* Modificado para otimizar as chamadas CALL, PUSH e POP				*
;* de forma a preservar o STACK								*
;**************************************************************
	ENDER EQU 11H		;ENDERECO DO EQUIPAMENTO

	STATUS_R EQU 28H		;STATUS REAL DO EQUIPAMENTO
;------- BITS DO STATUS:
	EXEC_ANDA EQU 40H		;BIT 0-EXECUCAO DO TRABALHO EM ANDAMENTO
	EXEC_ERRO EQU 41H		;BIT 1-EXECUCAO PARADA POR ERRO
	EXEC_PARADO EQU 42H	;BIT 2-FLAG QUE INDICA A REICIALIZACAO DOS PARAMETROS
	RC_TMP EQU 43H		;BIT 3 - INDICA QUE EXISTEM REGISTROS AGUARDANDO NA AREA TEMPORARIA
	;BIT_4 EQU 04H		;BIT 4 
	;BIT_5 EQU 05H
	;BIT_6 EQU 06H
	;BIT_7 EQU 07H

;SEQUENCIA DE OUTRAS FLAGS
;MEMORIA 29H
	BROADCAST EQU 48H	;FLAG INDICANDO RECEPCAO EM BROADCAST
	RECEB EQU 49H			;FLAG DE RECEPCAO DE BYTE NA SERIAL
	DIR_X EQU 4AH			;DIRECAO DO EIXO X
	DIR_Y EQU 4BH			;DIRECAO DO EIXO Y
	DIR_Z EQU 4CH			;DIRECAO DO EIXO Z
	RC_CMD EQU 4DH		;INDICA QUE EH SOMENTE UMA MENSAGEM DE COMANDO
	;----
	COMANDOS EQU 2AH		;O SEGUNDO BYTE  DO PRIMEIRO REGISTRO REPRESENTA OS COMANDOS RECEBIDOS
	;---------------------------------------------------
	;OS COMANDO ABAIXO SERAO RESETADOS IMEDITAMENTE APOS
	;SEU PROCESSAMENTO
	;----------------------------------------------------
	CMD_EXEC EQU 50H		;COMANDO DE EXECUCAO
	CMD_PAUSA EQU 51H		;COMANDO DE PAUSA NA EXECUCAO
	CMD_REST EQU 52H		;COMANDO DE RESTABELECER ERRO
	CMD_PARA EQU 53H		;COMANDO DE PARADA
	CMD_LIBERA EQU 54H		;COMANDO DE LIBERACAO DOS MOTORES
	CMD_ZERA EQU 55H		;COMANDO DE RESET DO CONTADOR DE OPERACOES
	;---

	BUF_POS EQU 60H 		;POSICAO ATUAL DO BUFFER
	BUF_BASE EQU 61H		;ENDERECO INICIAL DO BUFFER
	TAM_BUF EQU 1BH		;TAMANHO DO BUFFER (61h-7Ch)

	CRC_C EQU 7DH

	CRC_L EQU 7EH			;BYTE MENOS SIG DO CALCULO CRC
	CRC_H EQU 7FH		;BYTE MAIS SIG DO CALCULO CRC

	T_MSG EQU 28			;TEMPO LIMITE DE FIM DE MENSAGEM 
							;28 -> 4800 bauds
							;58 -> 2400 bauds
							;116 -> 1200 bauds

	QUANT_REG EQU 9		;QUANT DE REGISTROS
;--------------------------------------------------
	REGISTROS EQU 2EH		;ENDERECO DOS REGISTROS
	;O PRIMEIRO REGISTRO ESTA NOS BYTES 2E E 2F QUE
	;SERAO ENDERECAVEIS POR BITS
	;----
	STATUS_V EQU 2EH		;O PRIMEIRO BYTE REPRESENTA O STATUS DO EQUIPAMENTO
	;ESTE BYTE ESPELHA O BYTE DE STATUS REAL, QUE NAO EH MODIFICAVEL PELO USUARIO
	;----------------------------------------------------
	;EXEC_ANDA EQU 70H	;EXECUCAO DO TRABALHO EM ANDAMENTO
	;EXEC_ERRO EQU 71H	;EXECUCAO PARADA POR ERRO
	;EXEC_PARADO EQU 72H	;FLAG QUE INDICA A REINICIALIZACAO DOS PARAMETROS
	BIT_1 EQU 70H
	BIT_2 EQU 71H
	BIT_3 EQU 72H
	BIT_4 EQU 73H
	BIT_5 EQU 74H
	BIT_6 EQU 75H
	BIT_7 EQU 76H
	BIT_8 EQU 77H
	;----
	CONTADOR EQU 2FH  ;SEGUNDO BYTE: CONTADOR DE OPERACOES


;REGISTROS MESTRE DE TEMPO
	REG_A_4 EQU 30H
	REG_A_3 EQU 31H
	REG_A_2 EQU 32H
	REG_A_1 EQU 33H

;REGISTROS DO EIXO X
	REG_B_4 EQU 34H
	REG_B_3 EQU 35H
	REG_B_2 EQU 36H
	REG_B_1 EQU 37H

;REGISTROS DO EIXO Y
	REG_C_4 EQU 38H
	REG_C_3 EQU 39H
	REG_C_2 EQU 3AH
	REG_C_1 EQU 3BH

;REGISTROS DO EIXO Z
	REG_D_4 EQU 3CH
	REG_D_3 EQU 3DH
	REG_D_2 EQU 3EH
	REG_D_1 EQU 3FH

;---------------------------------------------------------------------------------
;VARIAVEIS DE VELOCIDADE DE EIXO
;EIXO X
	X_4 EQU 40H
	X_3 EQU 41H
	X_2 EQU 42H
	X_1 EQU 43H

;EIXO Y
	Y_4 EQU 44H
	Y_3 EQU 45H
	Y_2 EQU 46H
	Y_1 EQU 47H

;EIXO Z
	Z_4 EQU 48H
	Z_3 EQU 49H
	Z_2 EQU 4AH
	Z_1 EQU 4BH
;---------------------------------------------------
;BYTE A SER GIRADO EM CADA EIXO
	STEP_X EQU 2BH
	STEP_Y EQU 2CH
	STEP_Z EQU 2DH
	Z_b1 EQU 68H
	Z_b2 EQU 69H
	Z_b3 EQU 6aH
	Z_b4 EQU 6bH
	;Z_b5 EQU 6cH
	;Z_b6 EQU 6dH
	;Z_b7 EQU 6eH
	;Z_b8 EQU 6FH

;---------------------------------------------------
;ALOCA UM ESPACO PARA RECEBER DADOS ENQUANTO A MAQUINA ESTA EXECUTANDO
;ESTE ESPACO TEM A CAPACIDADE DOS REGISTROS E SERVIRA PARA ACELERAR O PROCESSO
;DE COMUNICACAO - ESTA NOS END 4D ATE 5F

	REG_TMP EQU 4DH
	CMD_TMP EQU 4EH
	VAR_TMP EQU 4FH

;*************************************************************

	ORG 00H				;INICIO DO PROG. EM 00H
	JMP INIC				;VAI PARA INICIO

	ORG 03H				;INTERRUPCAO EXTERNA 0
	jmp EXT_INT_0

	org	0Bh				; Interrupcao - T0
	jmp	T0_int

	ORG 13H				;INTERRUPCAO EXTERNA 1
	reti;
	
	ORG 1BH				;INTERRUPCAO TIMER 1
	reti;

	ORG 23H				;ENDRECO DA INT. SERIAL 23H
	JB RI,SERIAL  			;VAI PRA ROTINA SERIAL, SE RECEBEU DADOS
	CLR TI				;SENAO, LIMPA TI
	RETI					;E VOLTA

;******************** INTERRUPCAO SERIAL****************
SERIAL:
	push	psw			; Save PSW
	push	acc			; Save Acc
	push	0			; Save R0

	SETB RECEB			;INDICA QUE TEM BYTE RECEBIDO
	MOV R6, #0H			;ZERA CONTADOR DE TEMPO

	mov	a,BUF_POS		; Get End Of Buffer
	clr	c				; Clear Carry For Subtract
	subb	a,#TAM_BUF		; Subtract Input Buffer Length
	mov	a,BUF_POS		; Recover
	jc	SERIAL2			; If Carry Set, Value Is In Range
	clr	a				; Point Back To Start Of Buffer
SERIAL2:
	mov	r0,a				; Store To R0
	inc	a				; Point To Next Header Location
	mov	BUF_POS,a		; Store Back
	mov	a,#BUF_BASE		; Buffer Base Address
	add	a,r0				; Add In Count
	mov	r0,a				; Store Back To R0
	mov	a,sbuf			; Get Character At Serial Port
	mov	@r0,a			; Store Into Input Buffer
	;inc	CONTA_E			; Increment Number Of Characters In Buffer
;
SAI_SERIAL:
	pop	0				; Recover R0
	pop	acc				; Recover Acc
	pop	psw				; Recover PSW
	clr	ri				; Acknowledge We Got Character
	reti					; Return To Interrupted Routine

;******************** INTERRUPCAO TIMER 0 **************
T0_int:
	push	psw				; Salva PSW
	push	acc				; Salva Acc
	PUSH 	B

	JNB RECEB,T0_PROX0		;SE TEM BYTE RECEBIDO
	inc r6					;INCREMENTA R6
T0_PROX0:
	JB EXEC_PARADO,T0_PROX20	;E VERIFICA SE A MAQUINA NAO ESTA PARADA
	JB EXEC_ERRO,T0_PROX20	;E NEM TEM ERRO
	JB EXEC_ANDA,T0_PROX1		;VERIFICA SE HA O COMANDO DE EXECUCAO
	;
	MOV A, REG_A_1
	JNZ T0_PROX20
	MOV A, REG_A_2
	JNZ T0_PROX20
	MOV A, REG_A_3
	JNZ T0_PROX20
	MOV A, REG_A_4
	JNZ T0_PROX20
	SETB EXEC_PARADO

T0_PROX20:
	JMP SAI_T0
T0_PROX1:

;-------------------------- EIXO X ---------------------------------
	DJNZ X_1,T0_PROX4			;DECREMENTA OS BYTES DE TEMPO
	DJNZ X_2,T0_PROX4
	DJNZ X_3,T0_PROX4
	DJNZ X_4,T0_PROX4
	;------------- FIM DO TEMPO DE PASSO, EIXO X -----------
	JNB DIR_X, T0_PROX2		;VERIFICA QUAL A DIRECAO PARA GIRAR
	MOV A,STEP_X
	RR A						;GIRA PARA DIREITA
	MOV STEP_X,A
	JMP T0_PROX3
T0_PROX2:
	MOV A,STEP_X
	RL A						;OU PARA ESQUERDA
	MOV STEP_X,A
T0_PROX3:
	;RECARREGA OS VALORES DO EIXO X
	MOV X_4,REG_B_4
	ANL X_4,#7FH				;LIMPA O BIT DE DIRECAO
	MOV X_3,REG_B_3
	MOV X_2,REG_B_2
	MOV X_1,REG_B_1

;-------------------------- EIXO Y ---------------------------------
T0_PROX4:
	DJNZ Y_1,T0_PROX7			;DECREMENTA OS BYTES DE TEMPO
	DJNZ Y_2,T0_PROX7
	DJNZ Y_3,T0_PROX7
	DJNZ Y_4,T0_PROX7
	;------------- FIM DO TEMPO DE PASSO, EIXO Y -----------
	JNB DIR_Y, T0_PROX5		;VERIFICA QUAL A DIRECAO PARA GIRAR
	MOV A,STEP_Y
	RR A						;GIRA PARA DIREITA
	MOV STEP_Y,A
	JMP T0_PROX6
T0_PROX5:
	MOV A,STEP_Y
	RL A						;OU PARA ESQUERDA
	MOV STEP_Y,A
T0_PROX6:
	;RECARREGA OS VALORES DO EIXO Y
	MOV Y_4,REG_C_4
	ANL Y_4,#7FH				;LIMPA O BIT DE DIRECAO
	MOV Y_3,REG_C_3
	MOV Y_2,REG_C_2
	MOV Y_1,REG_C_1

;-------------------------- EIXO Z ---------------------------------
T0_PROX7:
	DJNZ Z_1,T0_PROX10		;DECREMENTA OS BYTES DE TEMPO
	DJNZ Z_2,T0_PROX10
	DJNZ Z_3,T0_PROX10
	DJNZ Z_4,T0_PROX10
	;------------- FIM DO TEMPO DE PASSO, EIXO Z -----------
	JNB DIR_Z, T0_PROX8	;VERIFICA QUAL A DIRECAO PARA GIRAR
	MOV A,STEP_Z
	RR A						;GIRA PARA DIREITA
	MOV STEP_Z,A
	JMP T0_PROX9
T0_PROX8:
	MOV A,STEP_Z
	RL A						;OU PARA ESQUERDA
	MOV STEP_Z,A

T0_PROX9:
	;RECARREGA OS VALORES DO EIXO Z
	MOV Z_4,REG_D_4
	ANL Z_4,#7FH				;LIMPA O BIT DE DIRECAO
	MOV Z_3,REG_D_3
	MOV Z_2,REG_D_2
	MOV Z_1,REG_D_1

;-------------------------------REGISTRO DE TEMPO MESTRE ----------------------
;-------------- DECREMENTA DIRETAMENTE DO PROPRIO REGISTRO --------------------
T0_PROX10:
	DJNZ REG_A_1,T0_PROX11	;DECREMENTA OS BYTES DE TEMPO
	DJNZ REG_A_2,T0_PROX11
	DJNZ REG_A_3,T0_PROX11
	DJNZ REG_A_4,T0_PROX11
	;AO FINAL PARA A EXECUCAO E DEIXA PRONTO PARA OUTRA
	;MOV STATUS_R,#00H		;REINICIA O STATUS
	CLR EXEC_ANDA
	SETB EXEC_PARADO			;MAQUINA PARADA
	JMP SAI_T0

T0_PROX11:
	;MANDA PARA A PORTA P1
	MOV B,STEP_X				;PEGA O VALOR DA PALAVRA DE PASSO DE X
	ANL B,#0FH				;ZERA O NIBLE MAIS ALTO
	MOV A,STEP_Y				;PEGA O VALOR DA PALAVRA DE PASSO DE Y
	ANL A,#0F0H				;ZERA O NIBLE BAIXO
	ORL A,B					;COMBINA OS DOIS NIBLES
	MOV P1,A					;E COLOCA EM P1
	
	;MANDA PARA A PORTA P3
	;EH FEITO BIT A BIT P/ EVITAR INTERRUPCOES INDESEJADAS
	mov c,Z_b1				;PRIMEIRO, PEGA O BIT DESEJADO E COLOCA NO CARRY
	mov p3.3,c				;DEPOIS MANDA O CARRY PARA A PORTA
	mov c,Z_b2
	mov p3.4,c
	mov c,Z_b3
	mov p3.5,c
	mov c,Z_b4
	mov p3.7,c

SAI_T0:
	POP B					; RESTAURA B
	pop	acc					; Recover Acc
	pop	psw					; Recover PSW
	reti
;******************** INTERRUPCAO EXTERNA 0 **************
	EXT_INT_0:
	SETB EXEC_ERRO		;SETA O BIT DE ERRO DE EXECUCAO
	
	reti

;************************** INICIO ***********************

INIC:
	;CONFIGURA PORTA SERIAL
	MOV IE,#00H			;DESABILITA TODAS INTERRUPCOES
	MOV PCON,#00H		;PORTA SERIAL NO MODO 1
	MOV SCON,#50H		;
	MOV TMOD,#22H		;TIMER 1 MODO 2(8 BITS) E TIMER0 MODO 2(8 BITS)
	
	MOV TH1,#0faH		;
	MOV TL1,#0faH			;4800 BAUDS -> CRISTAL 11.0592MHZ = fah
						;2400 BAUDS -> CRISTAL 11.0592MHZ = f4h
						;1200 BAUDS -> CRISTAL 11.0592MHZ = e8h

	mov	TH0, #01ah		;recarrega T0 para ter 250us -> CRISTAL 11.0592MHZ
	mov	TL0, #19h

	setb	Tr0				;dispara timer 0
	SETB TR1				;INICIA GERACAO DE BAUD RATE

	setb et0				;habilita interrupcao t0
	setb es				;habilita interrupcao serial
	setb ea				;habilita interrupcoes

	MOV BUF_POS,#0		;ZERA O BUFFER DE ENTRADA
	CLR RECEB			;ZERA FLAG DE RECEBIMENTO
	MOV R6,#0			;ZERA CONTADOR DE TEMPO

	CLR BROADCAST		;
	MOV CRC_C,#3			;INICIA O CONTADOR DE CRC
	MOV CRC_L, #0FFH		;INICIA O CRC
	MOV CRC_H, #0FFH		;INICIA O CRC

	MOV COMANDOS,#00H	;INICIA OS COMANDOS
	MOV CMD_TMP,#00H	;INICIA OS COMANDOS
	MOV STATUS_R,#00H	;INICIA O STATUS
	SETB EXEC_PARADO		;MAQUINA PARADA

	MOV STEP_X, #0CCH		;PALAVRA QUE ESTABELECE O TIPO DE PASSO DO MOTOR
	MOV STEP_Y, #0CCH		;PALAVRA QUE ESTABELECE O TIPO DE PASSO DO MOTOR
	MOV STEP_Z, #0CCH		;PALAVRA QUE ESTABELECE O TIPO DE PASSO DO MOTOR

	MOV CONTADOR, #00H		; ZERA CONTADOR DE OPERACOES

	;MOV DPTR,#MENS	;ENVIA MENSAGEM DE ABERTURA
	;CALL ENVIA	;

	JMP PRINCIPAL	;VAI PARA PRINCIPAL

;*********************** PRICIPAL *************************
PRINCIPAL:
	SETB ES					;REABILITA A INT. SERIAL
	MOV STATUS_V,STATUS_R	;ATUALIZA O REGISTRO DE STATUS VIRTUAL
	JNB RECEB,PRINC3			;VERIFICA SE HA MENSAGEM
;ENQUANTO ESPERA O FIM DE TRANSMISSAO, JA VAI CALCULANDO O CRC
	MOV A,BUF_POS			;PEGA O CONTADOR DE CARACTERES
	CJNE A,CRC_C,PRINC1		;VERIFICA SE JA ESTA MAIOR QUE 3
	SUBB A,#3				;PEGA O ULTIMO CARACTER ANTES DOS 3 BYTES FINAIS
	ADD A,#BUF_BASE			;EM RELACAO AO ENDERECO BASE DO BUFFER
	MOV R0,A					;
	MOV A,@R0				;
	CALL CRC					;CALCULA O CRC CONSIDERANDO O NOVO BYTE
	MOV A,CRC_C				;PASSA A ESPERAR UM NOVO CARACTER
	INC A					;
	MOV CRC_C,A				;

PRINC1:
	mov	a,#T_MSG				; VALOR DE ESPERA DO FIM DE MENSAGEM
	clr	c					; LIMPA Carry PARA SUBTRAIR
	subb a,R6					;VERIFICA SE R6 ESTA MENOR QUE O TEMPO LIMITE
	JNC PRINC3				;SE NAO TIVER CARRY, VOLTA NO INICIO

	CLR ES					;DESABILITA INTERRUPCAO SERIAL
	CLR RECEB				;ZERA FLAG DE RECEBIMENTO
	MOV R6,#0				;ZERA CONTADOR DE TEMPO

;VERIFICA O CRC COM OS DOIS ULTIMOS CARACTERES DA MENSAGEM
	MOV A,BUF_POS
	DEC A
	ADD A,#BUF_BASE
	MOV R0,A
	MOV A,@R0
	CJNE A,CRC_H,PRINC_SAI		;CONFERE O BYTE ALTO DO CRC
	DEC R0
	MOV A,@R0
	CJNE A,CRC_L,PRINC_SAI		;CONFERE O BYTE BAIXO DO CRC

;VERIFICA SE O ENDERECO DO EQUIPAMENTO BATE COM A MENSAGEM
	MOV R0,#BUF_BASE			;PEGA O PRIMEIRO CARACTER DO BUFFER
	MOV A,@R0				;
	CJNE A,#ENDER,PRINC2		;VERIFICA SE O ENDERECO DO EQUIP.
	JMP SEL_MODBUS
PRINC2:
	JNZ PRINC_SAI				;OU SE EH O ENDERECO 00
	SETB BROADCAST			;SE SIM, EH MENSAGEM DE BROADCAST
	JMP SEL_MODBUS

PRINC_SAI:
	CLR BROADCAST			;
	MOV CRC_C,#3
	MOV CRC_L, #0FFH			;INICIA O CRC
	MOV CRC_H, #0FFH			;INICIA O CRC

	MOV BUF_POS,#0			;ZERA O BUFFER DE ENTRADA
	SETB ES					;REABILITA A INT. SERIAL
PRINC3:
	MOV A, CMD_TMP
	JZ PRINC3a
	MOV COMANDOS, CMD_TMP
	MOV CMD_TMP,#00H		;ZERA O BYTE DOS COMANDOS PARA EVITAR ERROS NA PROXIMA

PRINC3a:
	JNB CMD_EXEC,PRINC4		;SE RECEBEU UM COMANDO DE EXECUTAR
	JNB EXEC_PARADO,PRINC4	; VERIFICA SE A MAQUINA NAO ESTA EM ANDAMENTO
	CLR CMD_EXEC				;LIMPA O BIT DE COMANDO
	JB EXEC_ERRO,PRINC4		;E SE NAO HOUVER ERRO
	SETB EXEC_ANDA			;LIBERA A EXECUCAO
	INC CONTADOR			;INCREMENTA O CONTADOR DE OPERACOES

PRINC4:
	JNB CMD_PAUSA,PRINC5		;SE RECEBEU UM COMANDO DE PAUSA
	CLR CMD_PAUSA			;LIMPA O BIT DE COMANDO
	CLR EXEC_ANDA			;INTERROMPE A EXECUCAO
PRINC5:
	JNB CMD_REST,PRINC6		;SE RECEBEU UM COMANDO DE RESETAR ERRO
	CLR CMD_REST				;LIMPA O BIT DE COMANDO
	CLR EXEC_ERRO			;LIMPA O BIT DE ERRO
PRINC6:
	JNB CMD_PARA,PRINC7		;SE RECEBEU UM COMANDO DE PARADA
	CLR CMD_PARA				;LIMPA O BIT DE COMANDO
	CLR CMD_EXEC				;LIMPA O COMANDO DE EXECUCAO, SE HOUVER
	CLR EXEC_ANDA			;INTERROMPE A EXECUCAO
	SETB EXEC_PARADO			;INDICA PARADO PARA REINICIO
PRINC7:
	JNB CMD_LIBERA,PRINC7a		;SE RECEBEU UM COMANDO DE LIBERA
	CLR CMD_LIBERA			;LIMPA O BIT DE COMANDO
	CLR EXEC_ANDA			;INTERROMPE A EXECUCAO
	SETB EXEC_PARADO			;INDICA PARADO PARA REINICIO
	MOV P1,#0FFH				;MOTORES SEM CORRENTE
	ORL P3,#0B8H				;
PRINC7a:
	JNB CMD_ZERA,PRINC8		;SE RECEBEU UM COMANDO DE RESET CONTADOR
	CLR CMD_ZERA			;LIMPA O BIT DE COMANDO
	MOV CONTADOR,#00H			;ZERA O CONTADOR

PRINC8:
	JNB EXEC_PARADO,PRINC10	; VERIFICA SE A MAQUINA NAO ESTA EM ANDAMENTO
	JNB RC_TMP,PRINC10		; E VERIFICA SE EXISTE DADOS RECEBIDOS AGUARDANDO
	;DE
	MOV R0,#VAR_TMP			;ENDERECO BASE DOS REGISTROS TEMPORARIOS
	;PARA
	MOV R1,#REG_A_4			;ENDERECO BASE DOS REGISTROS
	MOV R3,#16				; 16 BYTES
PRINC9:						;GRAVA OS REGISTROS				;
	MOV A,@R0				;
	MOV @R1,A				;
	INC R1					;
	INC R0					;BYTE A BYTE
	DJNZ R3,PRINC9			;VERIFICA SE JA ACABOU
	CLR RC_TMP

PRINC10:

PRINC20:
	JNB EXEC_ANDA,PRINC21		;VERIFICA SE HA O COMANDO DE EXECUCAO
	JNB EXEC_PARADO,PRINC21	;E VERIFICA SE A MAQUINA ESTAVA EM ANDAMENTO
;VERIF. P/ SABER SE AS VARIAVEIS DE MOVIMENTO DEVEM SER CARREGADAS
;-----------------INCIALIZA AS VARIAVEIS DE EIXO-----------------
;EIXO X
	MOV X_4,REG_B_4
	ANL X_4,#7FH				;LIMPA O BIT DE DIRECAO
	MOV X_3,REG_B_3
	MOV X_2,REG_B_2
	MOV X_1,REG_B_1

	;EIXO Y
	MOV Y_4,REG_C_4
	ANL Y_4,#7FH				;LIMPA O BIT DE DIRECAO
	MOV Y_3,REG_C_3
	MOV Y_2,REG_C_2
	MOV Y_1,REG_C_1

	;EIXO Z
	MOV Z_4,REG_D_4
	ANL Z_4,#7FH				;LIMPA O BIT DE DIRECAO
	MOV Z_3,REG_D_3
	MOV Z_2,REG_D_2
	MOV Z_1,REG_D_1

	;DIRECOES
	MOV A,#80H
	ANL A,REG_B_4				;EIXO X
	RLC A
	MOV DIR_X,C

	MOV A,#80H
	ANL A,REG_C_4				;EIXO Y
	RLC A
	MOV DIR_Y,C

	MOV A,#80H
	ANL A,REG_D_4				;EIXO Z
	RLC A
	MOV DIR_Z,C

	CLR EXEC_PARADO	;
	
PRINC21:
	JMP PRINCIPAL				;LOOP INFINITO

;****************** ROTINA DE SELECAO DE FUNCOES MODBUS ***********
SEL_MODBUS:
	MOV R0,#BUF_BASE			;
	INC R0					;PEGA O SEGUNDO CARACTER DO BUFFER
	MOV A,@R0				;
	JB BROADCAST, PROX2		;SE FOI BROADCAST, PASSA P/ FUNCOES QUE ACEITAM

	CJNE A,#03H,PROX1			;VERIFICA SE A FUNCAO MODBUS E 03 (LER REGISTROS)
	JMP MODBUS_3
PROX1:
	CJNE A,#08H,PROX2			;VERIFICA SE A FUNCAO MODBUS E 08 (DIAGNOSTICO)
	JMP MODBUS_8
PROX2:
	CJNE A,#10H,PROX3			;VERIFICA SE A FUNCAO MODBUS E 16 (ESCREVER REGISTROS)
	JMP MODBUS_16
PROX3:

ERRO_FUNCAO:
	MOV R7,#01				;COLOCA O ERRO 01 (FUNCAO NAO ACEITA)
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO

SEL_SAI:
	JMP PRINC_SAI				;RETORNA

;******************************** FUNCOES MODBUS *********************************
;-----FUNCAO MODBUS 03 - LE UM OU MAIS REGISTROS -------
MODBUS_3:
	;-----------COMECA A VERIFICACAO DE INTEGRIDADE DA MENSAGEM---------------
	MOV A,BUF_POS			; VERIFICA SE O NUMERO DE BYTES RECEBIDOS E 08
	CJNE A,#08H,ER_03_3		; SE NAO FOR, A FUNCAO ESTA ERRADA

	INC R0					;PEGA O TERCEIRO CARACTER DO BUFFER
	MOV A,@R0				;EH O BYTE ALTO DO PRIM. ENDERECO
	JNZ ER_03_2				;SE FOR ZERO CONTINUA, SENAO ERRO

	INC R0					;PEGA O QUARTO CARACTER DO BUFFER
	;						;EH O BYTE BAIXO DO PRIM. ENDERECO
	MOV A,#QUANT_REG			;
	CLR C					;VERIFICA SE ESTA DENTRO DOS END. ADMITIDOS
	SUBB A,@R0				;
	JC ER_03_2				;SENAO APONTA ERRO
	MOV R3,A					;GUARDA EM R3 A QUANT. DE REGISTROS POSSIVEIS
	INC R3
	MOV A,@R0				;
	MOV R2,A					;GUARDA EM R2 O PRIMEIRO ENDERECO

	INC R0					;PEGA O QUINTO CARACTER DO BUFFER
	MOV A,@R0				;EH O BYTE ALTO DA QUANT. REGISTROS
	JNZ ER_03_2				;SE FOR ZERO CONTINUA, SENAO ERRO

	INC R0					;PEGA O SEXTO CARACTER DO BUFFER
	;						;EH O BYTE BAIXO DA QUANT. REGISTROS
	MOV A,R3					;
	CLR C					;VERIFICA SE ESTA DENTRO DOS END. ADMITIDOS
	SUBB A,@R0				;
	JC ER_03_2				;SENAO APONTA ERRO
	MOV A,@R0				;
	MOV R3,A					;QUANT DE REGISTROS A SEREM LIDOS EM R3
	;-------------------------- FIM DA VERIFICACAO -------------------------
	;-------------------------- EXECUTA A FUNCAO ---------------------------
	MOV A,R2					;ENDERECO INICIAL DA MENSAGEM
	MOV B,#2					;CADA REGISTRO TEM 2 BYTES
	MUL AB					;DESLOCA O NUM DE BYTES EM RELACAO AO
	ADD A,#REGISTROS			;ENDERECO BASE DOS REGISTROS
	MOV R1,A					;		;
	MOV R0,#BUF_BASE			;INICIO DO BUFFER
	INC R0					;
	INC R0					;VAI PRO TERCEIRO BYTE DO BUFFER
	MOV A,R3					;ENDERECO INICIAL DA MENSAGEM
	MOV B,#2					;CADA REGISTRO TEM 2 BYTES
	MUL AB					;NUMERO DE BYTES A SEGUIR
	MOV @R0,A				;NO BUFFER
FUNC_03:						;LEITURA DOS REGISTROS
	INC R0					;
	MOV A,@R1				;PEGA O REGISTRO ATUAL
	MOV @R0,A				;
	INC R1					;
	INC R0					;BYTE A BYTE
	MOV A,@R1
	MOV @R0,A				;E COLOCA NO FUFFER
	INC R1
	DJNZ R3,FUNC_03			;VERIFICA SE JA ACABOU
	;--------------------------- MANDA MENSAGEM DE CONFIRMACAO ------------
	JB BROADCAST, FUNC_3_SAI	;PULA ENVIO SE FOI MENSAGEM DE BROADCAST
	MOV A,R0					;SUBTRAI DE R0
	SUBB A,#BUF_BASE			;O INICIO DO BUFFER
	INC A
	MOV BUF_POS,A			;PARA OBTER A QUANT. CARACTERES NO BUFFER
	JMP CRC_BUF				;CALCULA VALOR DO CRC PARA O RETORNO
							; e ENVIA A MENSAGEM DE RETORNO
FUNC_3_SAI:
	JMP PRINC_SAI
	;-------------------------------------------------------
ER_03_2:
	MOV R7,#2
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO (ENDER. INVALIDO)
	
ER_03_3:
	MOV R7,#3
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO (FORMATO INVAL)
	
;-------------- FIM FUNCAO 03 -----------------------------

;----FUNCAO MODBUS 8 - DIAGNOSTICO ----------
;--------- IMPLEMENTADA SOMENTE A SUBFUNCAO 00 - REPETE A MENS RECEBIDA -----------
MODBUS_8:
	INC R0					;PEGA O TERCEIRO CARACTER DO BUFFER
	MOV A,@R0				;
	CJNE A,#0H,ER_08_1			;VERIFICA SE E A SUBFUNCAO 00
	INC R0					;PEGA O QUARTO CARACTER DO BUFFER
	MOV A,@R0				;
	CJNE A,#0H,ER_08_1			;VERIFICA SE E A SUBFUNCAO 00
	MOV A,BUF_POS			;
	CJNE A,#08H,ER_08_3		;VERIFICA SE A QUANT. CARACTERES ESTA CERTA
	jmp ENV_BUF				;RETRANSMITE O BUFFER
	JMP PRINC_SAI
ER_08_1:
	MOV R7,#1
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO

ER_08_3:
	MOV R7,#3
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO

;-------------- FIM DA FUNCAO 08 ---------------

;----------- FUNCAO MODBUS 16 - ESCREVE UM OU MAIS REGISTROS -------
;--------- CODIGOS DE ERRO DA FUNCAO  ------------------------------
ER_16_2:
	MOV R7,#2
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO (ENDER. INVALIDO)

ER_16_3:
	MOV R7,#3
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO (FORMATO INVAL)

ER_16_6:
	MOV R7,#6
	jmp ER_MODBUS			;ENVIA CODIGO DE ERRO (EQUIP. OCUPADO)

;---------------------------------------------------------------------
MODBUS_16:
	;-----------COMECA A VERIFICACAO DE INTEGRIDADE DA MENSAGEM---------------
	MOV A,BUF_POS			; VERIFICA SE O NUMERO DE BYTES RECEBIDOS E IMPAR
	MOV B,#2					;
	DIV AB					;
	MOV A,B					;
	JZ ER_16_3				; SE NAO HOVER RESTO, A FUNCAO ESTA ERRADA
	MOV A,BUF_POS			; VERIFICA SE O NUMERO DE BYTES RECEBIDOS
	CLR C					;
	SUBB A,#0BH				;E MAIOR OU IGUAL A ONZE
	JC ER_16_3				;SENAO APONTA ERRO

	INC R0					;PEGA O TERCEIRO CARACTER DO BUFFER
	MOV A,@R0				;EH O BYTE ALTO DO PRIM. ENDERECO
	JNZ ER_16_2				;SE FOR ZERO CONTINUA, SENAO ERRO

	INC R0					;PEGA O QUARTO CARACTER DO BUFFER
	;						;EH O BYTE BAIXO DO PRIM. ENDERECO
	MOV A,#QUANT_REG			;
	CLR C					;VERIFICA SE ESTA DENTRO DOS END. ADMITIDOS
	SUBB A,@R0				;
	JC ER_16_2				;SENAO APONTA ERRO
	MOV R3,A					;GUARDA EM R3 A QUANT. DE REGISTROS POSSIVEIS
	MOV A,@R0				;
	MOV R2,A					;GUARDA EM R2 O PRIMEIRO ENDERECO
	;----------- VERIFICA SE EH O ENDERECO DE COMANDO
	CLR RC_CMD
	JNZ MODBUS_16_CONT1		;SE FOR ENDERECO 0,
	SETB RC_CMD				;TEM UM COMANDO NA MENSAGEM (PRIMEIRA PARTE)
	;-----------------------------------------------------
MODBUS_16_CONT1:
	INC R0					;PEGA O QUINTO CARACTER DO BUFFER
	MOV A,@R0				;EH O BYTE ALTO DA QUANT. REGISTROS
	JNZ ER_16_2				;SE FOR ZERO CONTINUA, SENAO ERRO

	INC R0					;PEGA O SEXTO CARACTER DO BUFFER
							;EH O BYTE BAIXO DA QUANT. REGISTROS
	MOV A,R3					;
	CLR C					;VERIFICA SE ESTA DENTRO DOS END. ADMITIDOS
	SUBB A,@R0				;
	JC ER_16_2				;SENAO APONTA ERRO
	MOV A,@R0				;
	MOV R3,A					;QUANT DE REGISTROS A SEREM LIDOS EM R3
	;----------- VERIFICA SE EH O ENDERECO DE COMANDO
	JNB RC_CMD,MODBUS_16_CONT2;
	CLR RC_CMD 
	CJNE A,#01H,MODBUS_16_CONT2	; confirma se TEM UM COMANDO NA MENSAGEM (SEGUNDA PARTE)
	SETB RC_CMD
	;-----------------------------------------------------
MODBUS_16_CONT2:
	MOV B,#2					;
	MUL AB					;CALCULA A QUANTIDADE DE BYTES NECESSARIOS
	MOV B,A					;
	INC R0					;PEGA O SETIMO CARACTER DO BUFFER
	MOV A,@R0				;INDICA A QUANTIDADE DE BYTES DE DADOS
	CJNE A,B,ER_16_3			; VERIFICA SE COINCIDE A QUANT. DE BYTES
	MOV A,BUF_POS			; VERIFICA SE O NUMERO DE BYTES DE DADOS RECEBIDOS
	CLR C					;
	SUBB A,#09H				;
	CJNE A,B,ER_16_3			; TAMBEM COINCIDE
	;-------------------------- FIM DA VERIFICACAO -------------------------
	;-------------------------- EXECUTA A FUNCAO ---------------------------
	MOV A,R2					;ENDERECO INICIAL DA MENSAGEM
	MOV B,#2					;CADA REGISTRO TEM 2 BYTES
	MUL AB					;DESLOCA O NUM DE BYTES EM RELACAO AO
	ADD A,#REG_TMP			;ENDERECO BASE DOS REGISTROS
	MOV R1,A					;
	PUSH 3
FUNC_16:						;GRAVA OS REGISTROS
	INC R0					;
	MOV A,@R0				;
	MOV @R1,A				;
	INC R1					;
	INC R0					;BYTE A BYTE
	MOV A,@R0
	MOV @R1,A
	INC R1
	DJNZ R3,FUNC_16			;VERIFICA SE JA ACABOU
	;-----------------------------------------------------
	JB RC_CMD,MODBUS_16_CONT3; SE NAO EH UM COMANDO
	SETB RC_TMP				; INDICA QUE HA DADOS NA AREA TEMPORARIA

MODBUS_16_CONT3:
	POP 3
	;--------------------------- MANDA MENSAGEM DE CONFIRMACAO ------------
	JB BROADCAST, FUNC_16_SAI	;PULA ENVIO SE FOI MENSAGEM DE BROADCAST
	MOV R0,#BUF_BASE		;
	INC R0					;
	INC R0					;VAI PRO TERCEIRO BYTE DO BUFFER
	MOV A,#0H				;ZERA O BYTE ALTO
	MOV @R0,A				;POE NO BUFFER
	MOV A,R2					;COLOCA O PRIM. ENDERECO
	INC R0					;
	MOV @R0,A				;NO BUFFER
	INC R0					;VAI PRO QUINTO BYTE DO BUFFER
	MOV A,#0H				;ZERA O BYTE ALTO
	MOV @R0,A				;POE NO BUFFER
	MOV A,R3					;COLOCA O NUM DE REGISTROS GRAVADOS
	INC R0					;
	MOV @R0,A				;NO BUFFER
	MOV BUF_POS,#6			;SEIS CARACTERES NO BUFFER
	jmp CRC_BUF				;CALCULA VALOR DO CRC PARA O RETORNO
							; e ENVIA A MENSAGEM DE RETORNO
FUNC_16_SAI:
	JMP PRINC_SAI
;-------------- FIM FUNCAO 16 -----------------------------

;*********** ROTINA DE ERRO NAS FUNCOES MODBUS ********************************
ER_MODBUS:
	MOV R0,#BUF_BASE			;
	INC R0					;PEGA O SEGUNDO CARACTER DO BUFFER
	MOV A,@R0				;
	ORL A,#80H				;SETA O BIT DE ERRO NA FUNCAO MODBUS
	MOV @R0,A				;DEVOLVE DO BUFFER
	MOV A,R7					;COLOCA O ERRO ARMAZENADO NO R7
	INC R0					;
	MOV @R0,A				;NO BUFFER
	MOV BUF_POS,#3			;TRES CARCTERES NO BUFFER
	;jmp CRC_BUF				;CALCULA VALOR DO CRC PARA O RETORNO

;*********** ROTINA DE CALCULO DE CRC DE UMA MENSAGEM NO BUFFER ***************
CRC_BUF:
	MOV CRC_L, #0FFH			;INICIA O CRC
	MOV CRC_H, #0FFH			;INICIA O CRC
	MOV R7,BUF_POS			;QUANTIDADE DE CARCTERES PARA O CALCULO
	MOV R1,#BUF_BASE			;
CRC_BUF1:	
	MOV A,@R1				;
	CALL CRC					;CALCULA O CRC CONSIDERANDO O NOVO BYTE
	INC R1					;PASSA PARA O PROXIMO
	DJNZ R7,CRC_BUF1			;VERIFICA SE ACABOU A MENSAGEM
	
	MOV A,CRC_L				;COLOCA O VALOR DO CRC NO FINAL DO BUFFER
	MOV @R1,A				;
	MOV A,CRC_H				;
	INC R1					;
	MOV @R1,A				;
	MOV A,BUF_POS			;E INCREMENTA OS BYTES ADICIONAIS
	ADD A,#2
	MOV BUF_POS,A

;********************** ROTINA DE ENVIO DO BUFFER *********
ENV_BUF:
	JNB BROADCAST,ENV_BUF0	;SE RECEBEU MENSAGEM DE BROADCAST
	JMP PRINC_SAI				;NAO ENVIA RESPOSTA
ENV_BUF0:
	MOV R7,BUF_POS			;QUANTIDADE DE CARACTERES PARA O ENVIO
	MOV R1,#BUF_BASE			;
	CLR TI					;ZERA TI
	;CLR ES					;DESABILITA INTERRUPCAO SERIAL
ENV_BUF1:
	MOV A,@R1				;
	MOV SBUF,A				;OS ENVIA
	JNB TI,$					;ESPERA FIM DE TRANSMISSAO
	CLR TI 					;
	INC R1					;PASSA PARA O PROXIMO
	DJNZ R7,ENV_BUF1			;VERIFICA SE ACABOU A MENSAGEM
	;SETB ES					;REABILITA A INT. SERIAL
	JMP PRINC_SAI				;RETORNA

;***************** ROTINA DE CALCULO DO CRC ******************
CRC:
	;push	0		; Save R0
	push	acc		; Save Acc
	mov	R4,#8		; 8 Bits In A Byte
	xrl	CRC_L,a		; LO ^= Data
CRC1:
	clr	c			; 0 Into high Bit
	mov	a,CRC_H		; D_CRC << 1
	rrc	a			; Shift rigth
	mov	CRC_H,a		; Store Back
	mov	a,CRC_L		; Get Low Byte
	rrc	a			; Shift rigth
	mov	CRC_L,a		; Store Back
	jnc	CRC2		; Skip If Bit 15 Wasn't Set
	xrl	CRC_H,#0a0h	; XOR In Polynomial High
	xrl	CRC_L,#01h	; XOR In Polynomial Low
CRC2:
	djnz	R4,CRC1		; Repeat R4 More Times
	pop	acc			; Recover Acc
	;pop	0			; Recover R0
	ret				; Return To Caller

;====================== AS ROTINAS A SEGUIR SAO PARA TESTE SOMENTE ========
	;----------SOMENTE PARA TESTE----------
	;MOV DPTR,#OK	;ENVIA MENSAGEM DE OK
	;CALL ENVIA	;
	;--------------------------------------

;****************** ROTINA DE ENVIO DE MENSAGENS*************

ENVIA:	MOV R0,#00H	;ZERA R0
	CLR TI			;ZERA TI
	CLR ES			;DESABILITA INTERRUPCAO SERIAL
LOOP:	MOV A,R0	;
	MOVC A,@A+DPTR	;CARREGA DADOS EM A E
	MOV SBUF,A		;OS ENVIA
	JNB TI,$			;ESPERA FIM DE TRANSMISSAO
	CLR TI 			;
	INC R0			;INCREMENTA R0
	CJNE A,#0,LOOP	;PASSA PARA PROXIMO CARACTERE OU
	SETB ES			;REABILITA A INT. SERIAL
	RET				;RETORNA

;****************** ROTINA DE ENVIO DE BYTES *****************

ENVIAB:	MOV SBUF,A	;MANDA CONTEUDO DE A PARA SERIAL
	JNB TI,$			;ESPERA TERMINO DA TRANSMISSAO
	CLR TI 			;PRONTO PARA OUTRO
	RET				;RETORNA

;****************** AREA DE DADOS E MENSAGENS *************

MENS:	DB 'Z','e','C','R','U','E','L',0DH,0H
OK:		DB '2','0','1','5',0DH,0H
;************************* FIM *****************************
END
